#include <iostream>
#include <vector>

using namespace std;

/*
НУжно найти все простые числа меньшие N. Заводим массив a, в котором элементы могут
принимать значения 1 или 0 (a[i] = 1 означает, что элемент простой).
*/

static const int N = 1000;

// Книжное решение
void eratosphen1(int* a, int N) {
	for (int i = 2; i < N; i++) a[i] = 1;
	for (int i = 2; i < N; i++) {
		if (a[i]) {
			for (int j = i; j*i < N; j++) a[j*i] = 0;
		}
	}
}

// e-maxx
/*
При этом мы начинаем идти от i^2, поскольку все меньшие числа, кратные i, обязательно имеют простой делитель меньше i, 
а значит, все они уже были отсеяны раньше. (Но поскольку i^2 легко может переполнить тип int, в коде перед вторым 
вложенным циклом делается дополнительная проверка с использованием типа long~long.)

При такой реализации алгоритм потребляет O (n) памяти (что очевидно) и выполняет O (n \log \log n).
*/
void eratosphen2(vector<char>& prime, int N) {
	for (int i = 2; i<= N; i++) {
		if (prime[i]) {
			if (i * 1ll * i <= N) {
				for (int j = i*i; j <= N; j += i) prime[j] = false;
			}
		}
	}
}

/*
Самый большой недостаток алгоритма — то, что он "гуляет" по памяти, постоянно выходя за пределы кэш-памяти, из-за чего 
константа, скрытая в O (n \log \log n), сравнительно велика.
Кроме того, для достаточно больших n узким местом становится объём потребляемой памяти.
Ниже рассмотрены методы, позволяющие как уменьшить число выполняемых операций, так и значительно сократить потребление 
памяти.

1) Просеивание простыми до корня
Самый очевидный момент — что для того, чтобы найти все простые до n, достаточно выполнить просеивание только простыми, 
не превосходящими корня из n.
Таким образом, изменится внешний цикл алгоритма:
for (int i=2; i*i<=n; ++i)
На асимптотику такая оптимизация не влияет (действительно, повторив приведённое выше доказательство, мы получим оценку 
n \ln \ln \sqrt{n} + o(n), что, по свойствам логарифма, асимптотически есть то же самое), хотя число операций заметно 
уменьшится.

2) Решето только по нечётным числам
Поскольку все чётные числа, кроме 2, — составные, то можно вообще не обрабатывать никак чётные числа, а оперировать 
только нечётными числами.
Во-первых, это позволит вдвое сократить объём требуемой памяти. Во-вторых, это уменьшит число делаемых алгоритмом 
операций примерно вдвое.

3) Уменьшение объёма потребляемой памяти
Заметим, что алгоритм Эратосфена фактически оперирует с n битами памяти. Следовательно, можно существенно сэкономить 
потребление памяти, храня не n байт — переменных булевского типа, а n бит, т.е. n/8 байт памяти.
Однако такой подход — "битовое сжатие" — существенно усложнит оперирование этими битами. Любое чтение или запись бита 
будут представлять из себя несколько арифметических операций, что в итоге приведёт к замедлению алгоритма.

Таким образом, этот подход оправдан, только если n настолько большое, что n байт памяти выделить уже нельзя. Сэкономив 
память (в 8 раз), мы заплатим за это существенным замедлением алгоритма.

В завершение стоит отметить, что в языке C++ уже реализованы контейнеры, автоматически осуществляющие битовое сжатие: 
vector<bool> и bitset<>. Впрочем, если скорость работы очень важна, то лучше реализовать битовое сжатие вручную, с 
помощью битовых операций — на сегодняшний день компиляторы всё же не в состоянии генерировать достаточно быстрый код.

4) Блочное решето
Из оптимизации "просеивание простыми до корня" следует, что нет необходимости хранить всё время весь массив 
prime[1...n]. Для выполнения просеивания достаточно хранить только простые до корня из n, т.е. 
prime[1...\sqrt{n}], а остальную часть массива prime строить поблочно, храня в текущий момент времени только один 
блок.
*/

int main() {
	int a[N];
	vector<char> prime(N+1, true);
	prime[0] = prime[1] = false;
}